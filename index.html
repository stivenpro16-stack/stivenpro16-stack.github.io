
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Esquiva los Aviones - Anime (funcional)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#111;
    color:#fff;
    font-family:Arial,Helvetica,sans-serif;
  }

  #gameArea{
    position:relative;
    width:400px;
    height:600px;
    background:linear-gradient(#2b2b2b,#1f1f1f);
    border:3px solid #fff;
    overflow:hidden;
    touch-action: none;
  }

  /* El jugador será un contenedor con SVG dentro */
  #player{
    position:absolute;
    bottom:18px;
    left:160px; /* se ajusta luego por JS según tamaño */
    width:80px;
    height:80px;
    pointer-events:none; /* para que clicks pasen al area */
    transform-origin:center;
  }

  /* Obstáculos (aquí se insertarán SVG directamente por JS) */
  .obstacle{
    position:absolute;
    width:60px;
    height:60px;
    top:0;
    pointer-events:none;
  }

  #score{position:absolute;left:10px;top:8px;font-size:18px}
  #level{position:absolute;left:10px;top:32px;color:yellow;font-size:16px}
  #gameOver{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    display:none;
    font-size:30px;color:#ffdd57;
    text-align:center;
  }

  /* Botones táctiles (opcionales) */
  .touch-controls{
    position:absolute;
    bottom:6px;
    right:6px;
    display:flex;
    gap:6px;
  }
  .btn{
    width:48px;height:48px;border-radius:8px;background:rgba(255,255,255,0.08);
    display:flex;align-items:center;justify-content:center;font-size:20px;color:#fff;user-select:none;
  }
  .btn:active{background:rgba(255,255,255,0.14)}
</style>
</head>
<body>
  <div id="gameArea">
    <div id="player" aria-label="jugador"></div>
    <div id="score">Puntos: 0</div>
    <div id="level">Nivel: 1</div>
    <div id="gameOver">¡Game Over!<br/>Pulsa R para reiniciar</div>

    <!-- controles tactiles (opcional) -->
    <div class="touch-controls" style="display:none" id="touchControls">
      <div class="btn" id="leftBtn">◀</div>
      <div class="btn" id="rightBtn">▶</div>
    </div>
  </div>

<script>
/*
  Versión robusta: jugador y aviones creados con SVG inline para evitar fallos de carga.
  Controles:
   - Flechas izquierda/derecha mueven al personaje.
   - R para reiniciar tras perder.
   - Soporta controles táctiles si el dispositivo es táctil (se habilitan automáticamente).
*/

const gameArea = document.getElementById('gameArea');
const player = document.getElementById('player');
const scoreText = document.getElementById('score');
const levelText = document.getElementById('level');
const gameOverText = document.getElementById('gameOver');
const touchControls = document.getElementById('touchControls');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

let score = 0;
let currentLevel = 1;
let gameOver = false;

let baseDropSpeed = 4; // velocidad base
let currentDropSpeed = baseDropSpeed;
let obstacleCreationInterval = 1000;
let obstaculoInterval = null;
let activeObstacles = new Set();

// posición en px desde la izquierda del contenedor
let playerX = 160; // se ajusta al cargar
let moveStep = 25; // pasos al presionar flecha

// Crear un SVG simple estilo "personaje anime" (simplificado)
function createPlayerSVG(){
  // Un SVG con cara, pelo (estilo anime muy simple). Lo hacemos responsive con viewBox.
  const svg = `
  <svg viewBox="0 0 100 100" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="personaje anime">
    <!-- Aura / sombra -->
    <ellipse cx="50" cy="86" rx="28" ry="8" fill="rgba(0,0,0,0.35)"/>
    <!-- Cuerpo -->
    <rect x="36" y="48" width="28" height="28" rx="6" fill="#264653"/>
    <!-- Cabeza -->
    <circle cx="50" cy="30" r="18" fill="#ffd7b5"/>
    <!-- Pelo (formas estilizadas) -->
    <path d="M32,28 C36,10 64,10 68,28 C62,22 38,22 32,28 Z" fill="#ffbe0b"/>
    <!-- Ojos -->
    <ellipse cx="43" cy="30" rx="3" ry="2" fill="#222"/>
    <ellipse cx="57" cy="30" rx="3" ry="2" fill="#222"/>
    <!-- Ropa detalle -->
    <path d="M50 52 L55 64 L45 64 Z" fill="#ff6b6b"/>
    <!-- Banda / diadema -->
    <rect x="30" y="20" width="40" height="6" rx="3" fill="#2a9d8f"/>
    <!-- Pequeño detalle brillante -->
    <circle cx="65" cy="20" r="2" fill="#fff" opacity="0.6"/>
  </svg>
  `;
  player.innerHTML = svg;
}

// Crear SVG de avión (devuelve string)
function airplaneSVG(color = '#e63946'){
  // Simple avión de frente inclinado
  return `
  <svg viewBox="0 0 64 64" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <g transform="translate(0,0)">
      <path d="M32 6 L38 22 L58 26 L38 30 L32 46 L26 30 L6 26 L26 22 Z" fill="${color}" stroke="#111" stroke-width="1"/>
      <rect x="28" y="30" width="8" height="12" rx="2" fill="#1d3557"/>
      <circle cx="48" cy="24" r="3" fill="#fff" opacity="0.4"/>
    </g>
  </svg>
  `;
}

// Ajustes iniciales (centrar jugador segun tamaños reales)
function ajustaPosicionInicial(){
  // centrar horizontalmente
  const areaW = gameArea.clientWidth;
  const playerW = player.clientWidth || 80;
  playerX = Math.max(0, Math.min(playerX, areaW - playerW));
  player.style.left = playerX + 'px';
}

createPlayerSVG();
ajustaPosicionInicial();

// Manejo de teclado
document.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){
    movePlayer(-moveStep);
  } else if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){
    movePlayer(moveStep);
  } else if(e.key === 'r' || e.key === 'R'){
    if(gameOver) reiniciarJuego();
  }
});

// Mover jugador y limitar dentro del área
function movePlayer(delta){
  if(gameOver) return;
  const maxX = gameArea.clientWidth - player.clientWidth;
  playerX += delta;
  if(playerX < 0) playerX = 0;
  if(playerX > maxX) playerX = maxX;
  player.style.left = playerX + 'px';
  // pequeña rotación visual cuando se mueve
  player.style.transform = `translateZ(0) rotate(${delta > 0 ? 8 : -8}deg)`;
  setTimeout(()=> player.style.transform = 'translateZ(0) rotate(0deg)',120);
}

// Detectar si el dispositivo tiene touch -> mostrar controles táctiles
function detectarTouch(){
  if('ontouchstart' in window || navigator.maxTouchPoints > 0){
    touchControls.style.display = 'flex';
  }
}
detectarTouch();

// Botones táctiles
leftBtn?.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); movePlayer(-moveStep); });
rightBtn?.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); movePlayer(moveStep); });
leftBtn?.addEventListener('mousedown', ()=> movePlayer(-moveStep));
rightBtn?.addEventListener('mousedown', ()=> movePlayer(moveStep));

// Función que crea un obstáculo (elemento div con SVG dentro)
function crearObstaculo(){
  if(gameOver) return;
  const div = document.createElement('div');
  div.className = 'obstacle';

  // probabilidad de rapido aumenta con nivel
  const probFast = Math.min(0.6, 0.2 + currentLevel * 0.05);
  const isFast = Math.random() < probFast;
  const color = isFast ? '#1e90ff' : '#e63946';
  div.innerHTML = airplaneSVG(color);

  // posicion horizontal en múltiplos de 25 (para que encaje con tu sistema original)
  const slots = Math.floor((gameArea.clientWidth - 60) / 25) + 1; // cantidad de posiciones horizontales
  const slot = Math.floor(Math.random() * slots);
  const leftPx = slot * 25;
  div.style.left = leftPx + 'px';

  gameArea.appendChild(div);
  activeObstacles.add(div);

  // velocidad del obstaculo
  const speedModifier = isFast ? 3 : 0;
  const dropSpeed = currentDropSpeed + speedModifier;

  // Animación con requestAnimationFrame para fluidez
  let posY = -10;
  let rafId = null;

  function step(){
    if(gameOver){ cancelAnimationFrame(rafId); return; }
    posY += dropSpeed * 0.6; // factor para ajustar ritmo
    div.style.top = posY + 'px';

    // detección de colisión usando getBoundingClientRect
    const obstRect = div.getBoundingClientRect();
    const playerRect = player.getBoundingClientRect();

    if(obstRect.left < playerRect.right &&
       obstRect.right > playerRect.left &&
       obstRect.top < playerRect.bottom &&
       obstRect.bottom > playerRect.top){
         // colisión
         finalizarJuego();
         cancelAnimationFrame(rafId);
         return;
    }

    if(posY > gameArea.clientHeight + 30){
      // fuera de pantalla -> eliminar y sumar punto
      if(div.parentElement) div.remove();
      activeObstacles.delete(div);
      incrementarPuntos();
      cancelAnimationFrame(rafId);
      return;
    }
    rafId = requestAnimationFrame(step);
  }

  rafId = requestAnimationFrame(step);
}

// incrementar puntos y chequear nivel
function incrementarPuntos(){
  score++;
  scoreText.textContent = 'Puntos: ' + score;
  if(score > 0 && score % 10 === 0 && currentLevel < 10){
    subirNivel();
  }
}

function subirNivel(){
  currentLevel++;
  levelText.textContent = 'Nivel: ' + currentLevel;
  currentDropSpeed = baseDropSpeed + (currentLevel - 1) * 1;
  obstacleCreationInterval = Math.max(400, 1000 - (currentLevel - 1) * 100);
  // reiniciar intervalo
  if(obstaculoInterval) clearInterval(obstaculoInterval);
  obstaculoInterval = setInterval(crearObstaculo, obstacleCreationInterval);
}

// iniciar creación de obstáculos
function iniciarObstaculos(){
  if(obstaculoInterval) clearInterval(obstaculoInterval);
  obstaculoInterval = setInterval(crearObstaculo, obstacleCreationInterval);
}

// finalizar juego
function finalizarJuego(){
  gameOver = true;
  gameOverText.style.display = 'block';
  // detener la creación de obstáculos
  if(obstaculoInterval) clearInterval(obstaculoInterval);
}

// reiniciar juego
function reiniciarJuego(){
  // limpiar obstáculos
  activeObstacles.forEach(el => { if(el.parentElement) el.remove(); });
  activeObstacles.clear();
  score = 0;
  currentLevel = 1;
  currentDropSpeed = baseDropSpeed;
  obstacleCreationInterval = 1000;
  scoreText.textContent = 'Puntos: 0';
  levelText.textContent = 'Nivel: 1';
  gameOver = false;
  gameOverText.style.display = 'none';
  ajustaPosicionInicial();
  iniciarObstaculos();
}

// manejar resize para ajustar límites
window.addEventListener('resize', ajustaPosicionInicial);

// iniciar por primera vez
iniciarObstaculos();

/* Soporte: mover jugador arrastrando con el ratón o tocando el area.
   Si arrastras horizontalmente el dedo/ratón, el jugador sigue.
*/
let dragging = false;
let lastClientX = 0;

function onPointerDown(e){
  dragging = true;
  lastClientX = e.touches ? e.touches[0].clientX : e.clientX;
}
function onPointerMove(e){
  if(!dragging || gameOver) return;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const dx = clientX - lastClientX;
  // convertir dx del viewport a dx relativo dentro del gameArea
  // aproximamos: mover la posición del jugador por dx
  movePlayer(dx > 0 ? Math.ceil(dx/12) : Math.floor(dx/12));
  lastClientX = clientX;
}
function onPointerUp(){
  dragging = false;
}

gameArea.addEventListener('mousedown', onPointerDown);
window.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup', onPointerUp);

gameArea.addEventListener('touchstart', onPointerDown, {passive:true});
window.addEventListener('touchmove', onPointerMove, {passive:true});
window.addEventListener('touchend', onPointerUp);

/* NOTA:
   Si prefieres usar una imagen específica (por URL) en vez del SVG inline,
   dime la URL y lo adapto. Pero esta versión no depende de URLs externas
   por lo que debería funcionar en cualquier navegador moderno.
*/
</script>
</body>
</html>
l>